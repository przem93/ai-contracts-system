---
description: Project overview
globs:
alwaysApply: true
---


# üß© AI Contracts System

## üß† Overview
**AI Contracts System** is a backend‚Äìfrontend platform that manages and visualizes **technical dependency contracts** across an application ecosystem.  
It ingests **YAML contract files** ‚Äî delivered from external repositories or services ‚Äî and uses them to represent the **real-world structure and relationships** between modules, APIs, and even React components.

The system transforms these YAML contracts into a **graph representation** stored in a Neo4j database, making it possible to explore, validate, and reason about dependencies programmatically or through a UI.

---

## ‚öôÔ∏è Key Features

- **External YAML ingestion**  
  The system accepts YAML files provided from outside sources (e.g. other repos or CI pipelines).

- **Real-state reflection**  
  Each YAML file describes the **actual current structure** of a project ‚Äî its modules, components, and interdependencies.

- **Configurable sources**  
  YAML file locations are defined via an `.env` variable, e.g.:
  ```bash
  CONTRACTS_PATH=/contracts/**/*.yml
  ```

---

## üìù Contract Definition Structure

### Valid Contract Parameters

Each YAML contract file must follow a specific structure to represent modules, components, and their dependencies accurately. Below is the complete specification of valid parameters:

#### **Root Properties**

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | string | ‚úÖ | **Unique identifier** for the contract. Used by other modules to reference this module in their dependencies. Must be unique across all contracts. |
| `type` | string | ‚úÖ | **Module type** (e.g., `controller`, `service`, `component`). Provides semantic information about the module's role. This helps AI models understand whether it's a backend controller, service layer, React.js frontend component, etc. |
| `category` | string | ‚úÖ | **Category classification** (e.g., `api`, `service`, `frontend`). Groups modules by their functional domain. Helps AI models understand the architectural layer this module belongs to. |
| `description` | string | ‚úÖ | **Human-readable description** of the module's purpose and functionality. Provides context for AI models to understand what this module does. |
| `parts` | array | ‚ùå | **Module parts** - An array of sub-components or exportable elements within this module (e.g., functions, classes, exports). Each part can be independently referenced by dependent modules. If omitted, the module is treated as atomic. |
| `dependencies` | array | ‚ùå | **Module dependencies** - An array of other modules that this module depends on. Dependencies are **unidirectional**: if module A lists module B in dependencies, it means A depends on B (A ‚Üí B), not the reverse. |

#### **Parts Structure** (`parts[]`)

Each element in the `parts` array represents an exportable component of the module:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | string | ‚úÖ | **Part identifier** - Unique within this module. Used by dependent modules to reference this specific part. |
| `type` | string | ‚úÖ | **Part type** - Describes the nature of this part (e.g., `string`, `function`, `class`, `interface`). **CRITICAL**: This type must match exactly when other modules reference this part in their dependencies. Type mismatches indicate refactoring needs. |

#### **Dependencies Structure** (`dependencies[]`)

Each element in the `dependencies` array represents a dependency on another module:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `module_id` | string | ‚úÖ | **Reference to another module** - Must match the `id` of an existing contract. This creates a directed edge in the dependency graph pointing to the referenced module. |
| `parts` | array | ‚úÖ | **Referenced parts** - List of specific parts from the referenced module that this module uses. A module doesn't need to use all parts of its dependency, only the required ones. |

#### **Dependency Parts Structure** (`dependencies[].parts[]`)

Each element specifies a part from the referenced module:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `part_id` | string | ‚úÖ | **Part reference** - Must match the `id` of a part defined in the referenced module. |
| `type` | string | ‚úÖ | **Part type verification** - Must match the `type` of the part in the referenced module. **CRITICAL**: This enforces type consistency across dependencies. If types don't match, it signals that refactoring or updates are needed. |

---

### üìã Valid Contract Examples

#### Example 1: API Controller with Dependencies

```yaml
id: users-get
type: controller
description: Users get endpoint
category: api
parts:
  - id: part
    type: string
dependencies:
  - module_id: users-permissions
    parts:
      - part_id: id
        type: string
      - part_id: name
        type: string
```

**Explanation**:
- This contract defines a `users-get` controller (API endpoint)
- It has one part with id `part` of type `string`
- It depends on the `users-permissions` module
- Specifically, it uses two parts from `users-permissions`: `id` and `name`, both of type `string`
- The dependency relationship is unidirectional: `users-get` ‚Üí `users-permissions`

#### Example 2: Service Module (Dependency Target)

```yaml
id: users-permissions
type: service
description: Users permissions service
category: service
parts:
  - id: id
    type: string
  - id: name
    type: string
```

**Explanation**:
- This contract defines a `users-permissions` service module
- It exports two parts: `id` and `name`, both of type `string`
- It has no dependencies (other modules depend on it)
- This is the module referenced by `users-get` in Example 1

---

### üéØ Key Concepts for AI Models

#### 1. **Unidirectional Dependencies**
Dependencies flow in one direction only. If module A lists module B in its `dependencies`, it creates the relationship A ‚Üí B. Module B does not automatically depend on A.

#### 2. **Part Type Matching**
When module A references a part from module B in its dependencies, the `type` field in A's dependency specification **must exactly match** the `type` field of that part in B's definition. This ensures type safety and helps identify when changes in one module require updates in dependent modules.

#### 3. **Granular Dependency Tracking**
Modules don't need to depend on an entire module ‚Äî they can specify exactly which `parts` they use. This enables fine-grained dependency analysis and impact assessment when parts change.

#### 4. **Contract Identity**
The `id` field serves as the unique identifier for the entire contract/module. It's used in `module_id` fields when establishing dependencies.

#### 5. **Semantic Metadata**
The `type`, `category`, and `description` fields provide semantic context that helps AI models understand:
- The architectural role of each module
- The domain or layer it belongs to
- Its purpose and functionality

This metadata is crucial for code generation, refactoring suggestions, and dependency validation.

---

## üé® Frontend Application Workflow

The frontend application provides a **three-step process** for building and managing contracts:

### Step 1: Reviewing Contracts
- **Purpose**: Review contracts and detect changes compared to what's stored in the Neo4j database
- **Features**:
  - Displays all current contracts for review
  - Compares contracts with the current state in Neo4j database
  - Shows a "Verify Contracts" button **only when changes are detected**
  - If no changes exist, the button is hidden and user cannot proceed to the next step
  - Provides visual indication of which contracts have been modified, added, or removed

### Step 2: Verification
- **Purpose**: Verify the validity of proposed contract changes
- **Features**:
  - Displays verification results for all contract changes
  - Validates contract structure, dependencies, and type consistency
  - Shows detailed validation messages (errors, warnings, success)
  - User can **apply changes only when verification is successful**
  - If verification fails, user must go back and fix issues before proceeding

### Step 3: Apply Changes
- **Purpose**: Apply verified changes to the Neo4j database
- **Features**:
  - **Success page**: Displays when all changes are successfully applied to the database
    - Shows summary of changes applied
    - Provides confirmation message
    - Allows user to return to review new contracts
  - **Error page**: Displays if any errors occurred during the application process
    - Shows detailed error messages
    - Explains what went wrong
    - Provides guidance on how to resolve issues

---

## üöÄ Running the Project

**Docker Compose is the only official option** to run this project. All services (frontend, backend, Neo4j database) are orchestrated through Docker Compose.

### API Namespace

The backend API is running under the **`/api` namespace URL**. All API endpoints are prefixed with `/api`.

For example:
- Contracts endpoint: `http://localhost:3000/api/contracts`
- Health check: `http://localhost:3000/api/health`

---

## üõ†Ô∏è Development Guidelines

### When Building Contract Management Features

1. **Always validate contracts** before allowing users to apply changes
2. **Show clear visual feedback** about what changed (added, modified, removed)
3. **Block progression** when no changes exist or validation fails
4. **Provide detailed error messages** when validation or application fails
5. **Maintain audit trail** of contract changes over time

### When Working with Dependencies

1. **Enforce type matching** between dependency references and part definitions
2. **Detect breaking changes** when part types are modified
3. **Show dependency graphs** to visualize module relationships
4. **Validate circular dependencies** and alert users
5. **Track impact** of changes across the dependency graph

---

## üß™ Integration Testing

The project uses **Playwright** for end-to-end integration testing of the frontend application. Tests are located in `frontend/tests/` and follow established best practices for maintainability and reusability.

### Testing Architecture

The integration tests follow the **Page Object Model (POM)** pattern with class-based abstractions for both pages and components:

#### **Page Abstractions (Class-Based)**
Page objects are implemented as **classes** that encapsulate page structure and provide methods to interact with specific pages:

- **BasePage** (`tests/pages/BasePage.ts`): Base class providing common functionality for all page objects
  - Navigation methods (`goto()`, `waitForPageLoad()`)
  - Utility methods (`getTitle()`, `takeScreenshot()`)
  - Shared functionality inherited by all page objects

- **Specific Page Objects** (e.g., `ContractsListPage.ts`): Classes extending `BasePage` with page-specific methods
  - Define page-specific locators as class properties
  - Provide high-level interaction methods
  - Encapsulate page structure and behavior
  - Enable reusable, maintainable test code

**Example structure**:
```typescript
export class ContractsListPage extends BasePage {
  readonly pageTitle: Locator;
  readonly contractCards: Locator;
  
  constructor(page: Page) {
    super(page);
    this.pageTitle = page.getByRole('heading', { name: 'AI Contracts System' });
  }
  
  async navigate() { /* ... */ }
  async getContractsCount(): Promise<number> { /* ... */ }
}
```

#### **Component Abstractions (Class-Based)**
Reusable UI components are also implemented as **classes** that wrap specific UI elements:

- **Alert** (`tests/components/Alert.ts`): Class wrapping MUI Alert components
- **ContractCard** (`tests/components/ContractCard.ts`): Class wrapping contract card elements
- **LoadingSpinner** (`tests/components/LoadingSpinner.ts`): Class wrapping loading spinner with wait methods

Each component class:
- Takes a `Locator` in its constructor
- Provides methods to interact with and verify the component
- Encapsulates component-specific behavior
- Can be reused across multiple tests

**Example structure**:
```typescript
export class Alert {
  readonly alert: Locator;
  
  constructor(alertLocator: Locator) {
    this.alert = alertLocator;
  }
  
  async verifyIsVisible() { /* ... */ }
  async verifyText(expectedText: string) { /* ... */ }
}
```

### Test Organization

Tests are **separated into individual files by functionality** to maintain clarity and modularity:

- **`contracts-list.spec.ts`**: Tests for contracts listing functionality
  - Loading state tests
  - Success state tests (displaying contracts)
  - Error state tests
  - Empty state tests
  - Contract details verification

- **Future test files**: Each major feature should have its own test file
  - `contract-verification.spec.ts`: Tests for contract verification flow
  - `contract-apply.spec.ts`: Tests for applying contract changes
  - etc.

This separation ensures:
- **Clear test organization**: Easy to locate tests for specific features
- **Parallel execution**: Tests can run independently
- **Maintainability**: Changes to one feature don't affect unrelated tests
- **Scalability**: New features can add new test files without cluttering existing ones

### Best Practices Applied

1. **Class-based abstractions for pages and components**
   - All page objects extend from `BasePage` class
   - All component wrappers are implemented as classes
   - Classes encapsulate locators and interaction methods
   - Promotes code reuse and maintainability

2. **One test file per feature/functionality**
   - Contracts listing has its own file (`contracts-list.spec.ts`)
   - Verification would have its own file (`contract-verification.spec.ts`)
   - Each file focuses on testing a single feature or workflow
   - Keeps test suites focused and maintainable

3. **API mocking for predictable tests**
   - Use Playwright's route interception to mock API responses
   - Tests are independent of backend state
   - Faster test execution
   - Predictable test results

4. **AAA (Arrange-Act-Assert) pattern**
   - **Arrange**: Set up test data and mock API responses
   - **Act**: Navigate to page and perform user actions
   - **Assert**: Verify expected outcomes

5. **Descriptive test names**
   - Test names clearly describe the scenario being tested
   - Use `should...` pattern for clarity
   - Examples: `should display contracts when API returns data`

### Running Integration Tests

```bash
# Run all tests
npm run test:e2e

# Run in UI mode (interactive)
npm run test:e2e:ui

# Run in headed mode (visible browser)
npm run test:e2e:headed

# Debug tests
npm run test:e2e:debug

# Run in Docker (CI/CD)
docker-compose --profile development run --rm frontend-test
```

### Writing New Integration Tests

When adding new integration tests, follow these guidelines:

1. **Create or extend page objects** for new pages (class-based)
2. **Extract reusable components** as component classes
3. **Write tests in separate files** for each distinct feature/functionality
4. **Use descriptive test names** that explain the scenario
5. **Mock API responses** using Playwright's route interception
6. **Follow AAA pattern**: Arrange, Act, Assert
7. **Use the existing class-based patterns** for consistency

### Test File Structure

```
frontend/tests/
‚îú‚îÄ‚îÄ pages/                  # Page object classes
‚îÇ   ‚îú‚îÄ‚îÄ BasePage.ts        # Base class with common functionality
‚îÇ   ‚îî‚îÄ‚îÄ ContractsListPage.ts   # Contracts list page object class
‚îú‚îÄ‚îÄ components/             # Component abstraction classes
‚îÇ   ‚îú‚îÄ‚îÄ Alert.ts           # Alert component class
‚îÇ   ‚îú‚îÄ‚îÄ ContractCard.ts    # Contract card component class
‚îÇ   ‚îî‚îÄ‚îÄ LoadingSpinner.ts  # Loading spinner component class
‚îú‚îÄ‚îÄ fixtures/              # Test data and mock responses
‚îÇ   ‚îî‚îÄ‚îÄ contracts-data.ts
‚îú‚îÄ‚îÄ contracts-list.spec.ts # Tests for contracts listing
‚îî‚îÄ‚îÄ README.md             # Testing documentation
```

