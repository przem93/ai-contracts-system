---
description: Project overview
globs:
alwaysApply: true
---


# üß© AI Contracts System

## üß† Overview
**AI Contracts System** is a backend‚Äìfrontend platform that manages and visualizes **technical dependency contracts** across an application ecosystem.  
It ingests **YAML contract files** ‚Äî delivered from external repositories or services ‚Äî and uses them to represent the **real-world structure and relationships** between modules, APIs, and even React components.

The system transforms these YAML contracts into a **graph representation** stored in a Neo4j database, making it possible to explore, validate, and reason about dependencies programmatically or through a UI.

---

## ‚öôÔ∏è Key Features

- **External YAML ingestion**  
  The system accepts YAML files provided from outside sources (e.g. other repos or CI pipelines).

- **Real-state reflection**  
  Each YAML file describes the **actual current structure** of a project ‚Äî its modules, components, and interdependencies.

- **Configurable sources**  
  YAML file locations are defined via an `.env` variable, e.g.:
  ```bash
  CONTRACTS_PATH=/contracts/**/*.yml
  ```

---

## üìù Contract Definition Structure

### Valid Contract Parameters

Each YAML contract file must follow a specific structure to represent modules, components, and their dependencies accurately. Below is the complete specification of valid parameters:

#### **Root Properties**

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | string | ‚úÖ | **Unique identifier** for the contract. Used by other modules to reference this module in their dependencies. Must be unique across all contracts. |
| `type` | string | ‚úÖ | **Module type** (e.g., `controller`, `service`, `component`). Provides semantic information about the module's role. This helps AI models understand whether it's a backend controller, service layer, React.js frontend component, etc. |
| `category` | string | ‚úÖ | **Category classification** (e.g., `api`, `service`, `frontend`). Groups modules by their functional domain. Helps AI models understand the architectural layer this module belongs to. |
| `description` | string | ‚úÖ | **Human-readable description** of the module's purpose and functionality. Provides context for AI models to understand what this module does. |
| `parts` | array | ‚ùå | **Module parts** - An array of sub-components or exportable elements within this module (e.g., functions, classes, exports). Each part can be independently referenced by dependent modules. If omitted, the module is treated as atomic. |
| `dependencies` | array | ‚ùå | **Module dependencies** - An array of other modules that this module depends on. Dependencies are **unidirectional**: if module A lists module B in dependencies, it means A depends on B (A ‚Üí B), not the reverse. |

#### **Parts Structure** (`parts[]`)

Each element in the `parts` array represents an exportable component of the module:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | string | ‚úÖ | **Part identifier** - Unique within this module. Used by dependent modules to reference this specific part. |
| `type` | string | ‚úÖ | **Part type** - Describes the nature of this part (e.g., `string`, `function`, `class`, `interface`). **CRITICAL**: This type must match exactly when other modules reference this part in their dependencies. Type mismatches indicate refactoring needs. |

#### **Dependencies Structure** (`dependencies[]`)

Each element in the `dependencies` array represents a dependency on another module:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `module_id` | string | ‚úÖ | **Reference to another module** - Must match the `id` of an existing contract. This creates a directed edge in the dependency graph pointing to the referenced module. |
| `parts` | array | ‚úÖ | **Referenced parts** - List of specific parts from the referenced module that this module uses. A module doesn't need to use all parts of its dependency, only the required ones. |

#### **Dependency Parts Structure** (`dependencies[].parts[]`)

Each element specifies a part from the referenced module:

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `part_id` | string | ‚úÖ | **Part reference** - Must match the `id` of a part defined in the referenced module. |
| `type` | string | ‚úÖ | **Part type verification** - Must match the `type` of the part in the referenced module. **CRITICAL**: This enforces type consistency across dependencies. If types don't match, it signals that refactoring or updates are needed. |

---

### üìã Valid Contract Examples

#### Example 1: API Controller with Dependencies

```yaml
id: users-get
type: controller
description: Users get endpoint
category: api
parts:
  - id: part
    type: string
dependencies:
  - module_id: users-permissions
    parts:
      - part_id: id
        type: string
      - part_id: name
        type: string
```

**Explanation**:
- This contract defines a `users-get` controller (API endpoint)
- It has one part with id `part` of type `string`
- It depends on the `users-permissions` module
- Specifically, it uses two parts from `users-permissions`: `id` and `name`, both of type `string`
- The dependency relationship is unidirectional: `users-get` ‚Üí `users-permissions`

#### Example 2: Service Module (Dependency Target)

```yaml
id: users-permissions
type: service
description: Users permissions service
category: service
parts:
  - id: id
    type: string
  - id: name
    type: string
```

**Explanation**:
- This contract defines a `users-permissions` service module
- It exports two parts: `id` and `name`, both of type `string`
- It has no dependencies (other modules depend on it)
- This is the module referenced by `users-get` in Example 1

---

### üéØ Key Concepts for AI Models

#### 1. **Unidirectional Dependencies**
Dependencies flow in one direction only. If module A lists module B in its `dependencies`, it creates the relationship A ‚Üí B. Module B does not automatically depend on A.

#### 2. **Part Type Matching**
When module A references a part from module B in its dependencies, the `type` field in A's dependency specification **must exactly match** the `type` field of that part in B's definition. This ensures type safety and helps identify when changes in one module require updates in dependent modules.

#### 3. **Granular Dependency Tracking**
Modules don't need to depend on an entire module ‚Äî they can specify exactly which `parts` they use. This enables fine-grained dependency analysis and impact assessment when parts change.

#### 4. **Contract Identity**
The `id` field serves as the unique identifier for the entire contract/module. It's used in `module_id` fields when establishing dependencies.

#### 5. **Semantic Metadata**
The `type`, `category`, and `description` fields provide semantic context that helps AI models understand:
- The architectural role of each module
- The domain or layer it belongs to
- Its purpose and functionality

This metadata is crucial for code generation, refactoring suggestions, and dependency validation.

